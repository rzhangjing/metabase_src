# 任务并发控制

<cite>
**本文档引用的文件**  
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj)
- [impl.clj](file://src/metabase/task/impl.clj)
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md)
- [job_factory.clj](file://src/metabase/task/job_factory.clj)
- [task_history.clj](file://src/metabase/task_history/models/task_history.clj)
- [send.clj](file://src/metabase/notification/task/send.clj)
- [core.clj](file://src/metabase/task/core.clj)
</cite>

## 目录
1. [引言](#引言)
2. [Metabase任务并发控制机制概述](#metabase任务并发控制机制概述)
3. [单节点锁机制](#单节点锁机制)
4. [分布式集群锁（cluster_lock）](#分布式集群锁cluster_lock)
5. [Quartz调度器级别的并发控制](#quartz调度器级别的并发控制)
6. [不同机制的适用场景与性能影响对比](#不同机制的适用场景与性能影响对比)
7. [高可用部署环境下的最佳实践](#高可用部署环境下的最佳实践)
8. [配置示例](#配置示例)
9. [常见死锁问题排查方法](#常见死锁问题排查方法)
10. [总结](#总结)

## 引言

Metabase作为一个开源的数据分析平台，支持多种后台任务的自动化执行，如数据库同步、脉冲通知发送、缓存更新等。在多实例部署或高并发场景下，确保这些任务不会被重复执行至关重要。任务的并发执行可能导致数据不一致、资源争用、性能下降甚至系统故障。

本文档全面介绍Metabase中防止任务并发执行的多种机制，包括单节点锁、分布式集群锁（`cluster_lock`）和Quartz调度器级别的并发控制。我们将深入分析每种机制的实现原理、适用场景和性能影响，并提供在高可用部署环境下的最佳实践建议。同时，文档包含具体的配置示例和常见死锁问题的排查方法，旨在为系统管理员和开发者提供一份详尽的参考指南。

## Metabase任务并发控制机制概述

Metabase通过分层的并发控制机制来确保后台任务的稳定和可靠执行。这些机制主要分为三个层次：

1.  **应用层锁（Application-Level Locks）**：这是最直接的控制方式，通过在代码中使用锁来防止同一JVM进程内的并发执行。例如，使用`locking`宏来实现单节点内的互斥。
2.  **数据库层分布式锁（Database-Level Distributed Locks）**：当部署多个Metabase实例时，需要跨节点的协调。Metabase利用其应用数据库（App DB）中的`metabase_cluster_lock`表来实现一个分布式的锁机制，确保在集群中只有一个实例能获得特定任务的执行权。
3.  **调度器层并发控制（Scheduler-Level Concurrency Control）**：Metabase底层使用Quartz调度器来管理所有后台任务。Quartz本身提供了强大的并发控制能力，特别是通过`@DisallowConcurrentExecution`注解来防止同一个任务的多个实例同时运行。

这三种机制并非相互替代，而是根据不同的部署场景和需求协同工作。例如，在单节点部署中，应用层锁和Quartz的并发控制足以满足需求；而在多节点集群部署中，则必须依赖数据库层的分布式锁来保证全局一致性。

**Section sources**
- [impl.clj](file://src/metabase/task/impl.clj#L0-L377)
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L0-L159)

## 单节点锁机制

单节点锁机制是防止任务并发执行的最基本方法，它主要依赖于JVM内部的同步原语。在Metabase中，这种机制通常用于那些不支持多实例部署的场景，或者作为其他更复杂锁机制的补充。

### 实现原理

在Clojure中，`locking`宏是实现单节点锁的核心工具。它利用Java的`synchronized`关键字，确保同一时刻只有一个线程可以进入被锁定的代码块。当一个线程获得锁后，其他试图进入该代码块的线程将被阻塞，直到锁被释放。

在Metabase的代码中，单节点锁的应用体现在`cluster_lock.clj`文件中。当检测到数据库类型为H2时，系统会自动降级为使用`locking`宏，因为H2数据库不支持多实例共享，因此不需要复杂的分布式锁。

```clojure
;; 在 cluster_lock.clj 中的实现
(cond
  ;; h2 does not respect the query timeout when taking the lock
  ;; we do not support multiple instances for h2 however, so an in-process lock is sufficient.
  (= (mdb.connection/db-type) :h2) (locking do-with-cluster-lock (thunk))
  ...)
```

### 适用场景

单节点锁适用于以下情况：
*   **开发和测试环境**：使用H2作为内嵌数据库的单实例部署。
*   **非关键的、短时任务**：那些即使偶尔并发执行也不会造成严重后果的任务。
*   **作为分布式锁的后备方案**：在分布式锁不可用时提供基本的保护。

### 局限性

单节点锁的最大局限性在于其作用域仅限于单个JVM进程。在多实例部署中，每个实例都有自己的锁，它们之间无法感知对方的存在，从而无法防止跨实例的并发执行。因此，在生产环境的高可用部署中，单节点锁不能作为主要的并发控制手段。

**Section sources**
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj#L0-L105)

## 分布式集群锁（cluster_lock）

为了应对多实例部署的挑战，Metabase实现了基于应用数据库的分布式集群锁机制。这是确保在高可用环境中任务不被重复执行的核心保障。

### 实现原理

分布式集群锁的实现位于`src/metabase/app_db/cluster_lock.clj`文件中。其核心思想是利用数据库的**唯一约束（Unique Constraint）**和**事务（Transaction）**来实现互斥。

1.  **锁表结构**：Metabase创建了一个名为`metabase_cluster_lock`的表，其中`lock_name`字段被设置为唯一主键。
2.  **获取锁**：当一个实例想要执行一个需要加锁的任务时，它会执行一个包含以下步骤的事务：
    *   尝试向`metabase_cluster_lock`表中插入一条以特定`lock_name`（如`::statistics-lock`）为主键的记录。
    *   如果插入成功，说明该实例成功获得了锁，可以继续执行任务。
    *   如果插入失败（抛出`SQLIntegrityConstraintViolationException`），说明另一个实例已经持有该锁，当前实例需要等待或重试。
3.  **释放锁**：锁的释放是通过事务的自动提交或回滚来完成的。当持有锁的实例完成任务并提交事务时，它插入的记录会成为持久化数据。然而，真正的“释放”是通过**删除**这条记录来实现的。在`do-with-cluster-lock*`函数的执行完成后，事务提交，但锁的持有状态是通过记录的存在来表示的。后续的实例在尝试获取锁时，会因为唯一约束而失败，从而实现了互斥。

为了处理获取锁时可能发生的超时或并发冲突，该机制还集成了重试逻辑（`retryable?`函数和`default-retry-config`），允许在失败后进行多次重试。

### 适用场景

分布式集群锁是Metabase在生产环境中的标准做法，适用于：
*   **任何多实例部署**：无论是在Kubernetes集群、AWS ECS还是其他云平台上运行的多个Metabase实例。
*   **需要全局互斥的任务**：如批量更新卡片统计信息（`card-statistics-lock`）、执行数据库迁移等，这些任务必须确保在任何时刻都只有一个实例在执行。
*   **对数据一致性要求高的操作**。

### 性能影响

虽然分布式锁非常可靠，但它也带来了一定的性能开销：
*   **网络延迟**：每次获取锁都需要与数据库进行一次或多次交互，增加了任务的启动延迟。
*   **数据库负载**：频繁的锁竞争会导致大量的`INSERT`和`SELECT FOR UPDATE`操作，增加数据库的CPU和I/O负载。
*   **重试开销**：在高并发场景下，实例可能需要多次重试才能成功获取锁，浪费了计算资源。

因此，应谨慎使用分布式锁，仅在真正需要时才加锁，并尽量缩短持有锁的时间。

**Section sources**
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj#L0-L105)

## Quartz调度器级别的并发控制

Quartz是Metabase背后的核心调度引擎，它不仅负责任务的定时触发，还提供了强大的并发控制能力。这是防止任务并发执行的第一道防线。

### 实现原理

Quartz的并发控制主要通过`@DisallowConcurrentExecution`注解来实现。当一个任务类（Job）被标记了这个注解后，Quartz调度器会确保该任务的多个实例不会同时运行。

在Metabase的代码中，这一机制被广泛使用。例如，在`src/metabase/notification/task/send.clj`文件中，`InitNotificationTriggers`任务就被明确标记为不允许并发执行：

```clojure
(task/defjob
  ^{:doc "..."
    DisallowConcurrentExecution true}
  InitNotificationTriggers
  [_context]
  ...)
```

其工作原理如下：
1.  当一个被标记的任务开始执行时，Quartz会将该任务的状态标记为“正在运行”。
2.  如果调度器根据计划再次触发该任务，它会检查任务的当前状态。
3.  如果任务仍在运行，新的触发将被忽略或推迟（取决于具体的misfire处理策略），直到前一个实例完成。

### 适用场景

Quartz级别的并发控制适用于：
*   **长运行任务**：防止一个任务的多个实例堆积，耗尽系统资源。
*   **操作共享资源的任务**：避免多个实例同时修改同一份数据。
*   **所有通过Quartz调度的任务**：作为一项基本的安全措施，建议为所有可能产生并发问题的任务添加此注解。

### 与分布式锁的关系

Quartz的并发控制和分布式集群锁是互补的：
*   **Quartz锁**：解决**单个实例内**的并发问题。即使在一个实例中，如果任务执行时间很长，而调度周期很短，没有此注解就会导致并发。
*   **集群锁**：解决**多个实例间**的并发问题。即使Quartz防止了单实例内的并发，也无法阻止另一个实例同时运行同一个任务。

因此，在一个健壮的系统中，两者通常会结合使用。例如，一个任务可能既被标记为`DisallowConcurrentExecution`，又在执行关键代码段时获取`cluster_lock`。

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L92-L138)
- [send.clj](file://src/metabase/notification/task/send.clj#L0-L211)

## 不同机制的适用场景与性能影响对比

下表总结了Metabase中三种主要并发控制机制的特性、适用场景和性能影响：

| 特性/机制 | 单节点锁 (`locking`) | 分布式集群锁 (`cluster_lock`) | Quartz 并发控制 (`@DisallowConcurrentExecution`) |
| :--- | :--- | :--- | :--- |
| **作用范围** | 单个JVM进程内 | 跨所有共享同一App DB的Metabase实例 | 单个Metabase实例内 |
| **实现基础** | JVM同步原语 (`synchronized`) | 数据库唯一约束和事务 | Quartz调度器状态管理 |
| **主要用途** | H2数据库的后备方案，或非关键任务 | 多实例部署下的全局互斥，关键任务协调 | 防止单实例内任务堆积 |
| **适用场景** | 单实例部署，开发/测试环境 | 生产环境的高可用部署，需要全局锁的任务 | 所有长运行或操作共享资源的任务 |
| **性能影响** | 极低，仅为内存操作 | 较高，涉及数据库网络I/O和潜在的重试 | 低，为调度器内部状态检查 |
| **可靠性** | 仅限于单节点，多节点下无效 | 高，基于数据库的强一致性 | 高，但仅限于单实例 |
| **配置复杂度** | 无，代码内置 | 无，自动使用App DB | 低，通过注解标记任务类 |

**结论**：在生产环境中，应优先使用**分布式集群锁**来保证跨实例的互斥。同时，为所有任务启用**Quartz的并发控制**作为基础防护。单节点锁仅作为特定场景（如H2）的补充。

**Section sources**
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj#L0-L105)
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L92-L138)
- [impl.clj](file://src/metabase/task/impl.clj#L0-L377)

## 高可用部署环境下的最佳实践

在部署高可用的Metabase集群时，遵循以下最佳实践可以有效避免任务并发问题：

1.  **始终启用分布式锁**：确保所有实例都连接到同一个外部数据库（如PostgreSQL或MySQL），并使用该数据库作为App DB。这是实现集群锁的前提。
2.  **为所有任务添加 `@DisallowConcurrentExecution`**：在定义新的Quartz任务时，养成习惯性地添加`^{:DisallowConcurrentExecution true}`元数据。这可以防止因调度配置错误导致的单实例内并发。
3.  **最小化锁持有时间**：在使用`with-cluster-lock`时，应将锁的范围限制在真正需要互斥的代码段上。避免在持有锁期间执行耗时的网络请求或复杂的计算。
4.  **合理设置重试策略**：`cluster_lock`机制内置了重试逻辑。在高并发场景下，可以适当调整`default-retry-config`中的`max-attempts`和`initial-interval-millis`，以平衡响应速度和数据库压力。
5.  **监控任务执行历史**：利用`task_history`表来监控关键任务的执行情况。通过查询`task_history`，可以发现任务是否被意外跳过或执行时间异常，这往往是并发问题的征兆。
6.  **避免过度使用锁**：不是所有任务都需要加锁。对于幂等性操作或影响范围很小的任务，可以考虑不加锁以提高系统吞吐量。

**Section sources**
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj#L0-L105)
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L92-L138)
- [task_history.clj](file://src/metabase/task_history/models/task_history.clj#L0-L198)

## 配置示例

### 1. 定义一个禁止并发执行的Quartz任务

在Clojure代码中，可以通过`task/defjob`宏和`DisallowConcurrentExecution`元数据来定义一个任务。

```clojure
(require '[metabase.task.core :as task])

(task/defjob ^{org.quartz.DisallowConcurrentExecution true} MyCriticalTask [_]
  (println "This task will never run concurrently with itself."))
```

### 2. 使用分布式集群锁执行关键代码

使用`with-cluster-lock`宏来保护一段需要全局互斥的代码。

```clojure
(require '[metabase.app-db.cluster-lock :as cluster-lock])

;; 使用预定义的锁
(cluster-lock/with-cluster-lock cluster-lock/card-statistics-lock
  (fn []
    (println "正在批量更新卡片统计信息...")
    ;; 执行更新操作
    ))

;; 或使用自定义锁名
(cluster-lock/with-cluster-lock {:lock-name ::my-custom-lock :timeout-seconds 5}
  (fn []
    (println "正在执行自定义关键任务...")
    ;; 执行任务
    ))
```

### 3. 初始化并调度一个任务

在任务的初始化方法中，将任务和触发器注册到调度器。

```clojure
(def my-job-key (jobs/key "my.critical.task.job"))
(def my-trigger-key (triggers/key "my.critical.task.trigger"))

(defmethod task/init! ::MyCriticalTask [_]
  (let [job (jobs/build
             (jobs/of-type MyCriticalTask)
             (jobs/with-identity my-job-key)
             (jobs/store-durably))
        trigger (triggers/build
                 (triggers/with-identity my-trigger-key)
                 (triggers/for-job my-job-key)
                 (triggers/start-now)
                 (triggers/with-schedule
                  (cron/schedule "0 0 2 * * ? *")))] ; 每天凌晨2点执行
    (task/schedule-task! job trigger)))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L27-L90)
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj#L83-L104)

## 常见死锁问题排查方法

尽管Metabase的锁机制设计得较为健壮，但在复杂环境下仍可能出现死锁或锁争用问题。以下是排查这些问题的方法：

1.  **检查 `task_history` 表**：
    *   查询长时间处于`started`状态的任务，这可能意味着任务在执行过程中卡住，导致锁无法释放。
    ```sql
    SELECT * FROM task_history WHERE status = 'started' AND started_at < NOW() - INTERVAL '1 hour';
    ```

2.  **监控数据库锁**：
    *   对于PostgreSQL，可以查询`pg_locks`视图来查看当前的锁持有情况。
    *   对于MySQL，可以查询`information_schema.INNODB_LOCKS`和`INNODB_LOCK_WAITS`表。
    *   查找与`metabase_cluster_lock`表相关的锁，确认是否有长时间未释放的锁。

3.  **分析应用日志**：
    *   在Metabase日志中搜索`Obtained cluster lock`和`Failed to run statement with cluster lock`等关键字。
    *   如果频繁出现获取锁失败的日志，说明存在严重的锁竞争，需要优化任务的执行频率或持有锁的时间。

4.  **检查Quartz调度器状态**：
    *   使用`task/scheduler-info`函数（如果可用）来获取调度器的详细信息，检查任务和触发器的状态。
    *   确认任务没有因为错误而进入`ERROR`状态，这可能导致调度器停止触发。

5.  **审查任务代码**：
    *   检查持有锁的代码块中是否有潜在的无限循环、长时间的外部API调用或数据库查询，这些都可能导致锁被长时间占用。

通过结合日志、数据库监控和任务历史记录，可以有效地定位和解决由并发控制机制引发的问题。

**Section sources**
- [task_history.clj](file://src/metabase/task_history/models/task_history.clj#L0-L198)
- [cluster_lock.clj](file://src/metabase/app_db/cluster_lock.clj#L0-L105)
- [impl.clj](file://src/metabase/task/impl.clj#L0-L377)

## 总结

Metabase通过多层次的并发控制机制，有效地保障了后台任务在各种部署环境下的安全执行。从JVM层面的单节点锁，到基于数据库的分布式集群锁，再到Quartz调度器自身的并发控制，这些机制共同构成了一个健壮的防护体系。

在单实例部署中，Quartz的`@DisallowConcurrentExecution`注解足以防止任务堆积。而在生产环境的高可用集群中，必须依赖`metabase_cluster_lock`表来实现跨实例的全局互斥。最佳实践是将这两种机制结合使用，即为任务添加并发控制注解，并在执行关键操作时获取分布式锁。

管理员和开发者应充分理解每种机制的原理、适用场景和性能影响，合理配置和使用这些工具。通过监控`task_history`表和应用日志，可以及时发现并解决潜在的并发和死锁问题，确保Metabase系统的稳定和高效运行。