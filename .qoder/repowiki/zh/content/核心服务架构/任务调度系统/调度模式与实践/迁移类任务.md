# 迁移类任务

<cite>
**本文档引用的文件**
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj)
- [custom_migrations/util.clj](file://src/metabase/app_db/custom_migrations/util.clj)
- [custom_migrations/metrics_v2.clj](file://src/metabase/app_db/custom_migrations/metrics_v2.clj)
- [custom_migrations/pulse_to_notification.clj](file://src/metabase/app_db/custom_migrations/pulse_to_notification.clj)
- [json_migration.clj](file://src/metabase/models/json_migration.clj)
- [core.clj](file://src/metabase/app_db/core.clj)
- [setup.clj](file://src/metabase/app_db/setup.clj)
- [liquibase.clj](file://src/metabase/app_db/liquibase.clj)
- [migrate.clj](file://src/metabase/cmd/migrate.clj)
</cite>

## 目录
1. [概述](#概述)
2. [系统架构](#系统架构)
3. [核心组件分析](#核心组件分析)
4. [迁移任务实现方式](#迁移任务实现方式)
5. [幂等性设计](#幂等性设计)
6. [执行顺序控制](#执行顺序控制)
7. [回滚策略](#回滚策略)
8. [错误处理和状态追踪](#错误处理和状态追踪)
9. [自定义迁移示例](#自定义迁移示例)
10. [最佳实践](#最佳实践)

## 概述

Metabase的迁移系统是一个复杂而强大的数据和模式管理框架，负责处理数据库schema变更、数据格式升级和版本兼容性处理。该系统采用分层架构，结合Liquibase和自定义迁移机制，确保迁移过程的安全性和可靠性。

迁移系统的核心目标包括：
- 安全地执行数据库schema变更
- 处理复杂的数据格式升级
- 确保迁移操作的幂等性
- 提供完善的回滚机制
- 支持破坏性变更的安全执行

## 系统架构

```mermaid
graph TB
subgraph "应用层"
A[命令行接口] --> B[迁移入口点]
C[Web界面] --> B
end
subgraph "迁移管理层"
B --> D[迁移控制器]
D --> E[Liquibase集成]
D --> F[自定义迁移引擎]
end
subgraph "执行层"
E --> G[SQL迁移]
F --> H[数据迁移]
F --> I[配置迁移]
end
subgraph "存储层"
G --> J[数据库Schema]
H --> K[业务数据]
I --> L[应用设置]
end
subgraph "监控层"
M[状态追踪] --> N[错误报告]
N --> O[日志记录]
end
D --> M
```

**图表来源**
- [core.clj](file://src/metabase/app_db/core.clj#L1-L50)
- [setup.clj](file://src/metabase/app_db/setup.clj#L1-L50)

## 核心组件分析

### 1. 迁移控制器

迁移控制器是整个迁移系统的核心协调器，负责管理不同类型的迁移任务。

```mermaid
classDiagram
class MigrationController {
+migrate! data-source direction
+setup-db! db-type data-source
+release-migration-locks! timeout
-verify-db-connection db-type data-source
-run-schema-migrations data-source auto-migrate?
-check-encryption()
-error-if-downgrade-required data-source
}
class LiquibaseIntegration {
+migrate-up-if-needed! liquibase
+force-migrate-up-if-needed! liquibase
+rollback-major-version! liquibase
+consolidate-liquibase-changesets liquibase
+wait-for-all-locks sleep timeout
}
class CustomMigrationEngine {
+define-reversible-migration name body rollback
+define-migration name body
+should-execute-change?()
+no-op()
}
MigrationController --> LiquibaseIntegration
MigrationController --> CustomMigrationEngine
```

**图表来源**
- [setup.clj](file://src/metabase/app_db/setup.clj#L50-L100)
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L50-L100)

### 2. 自定义迁移引擎

自定义迁移引擎提供了灵活的数据迁移能力，支持复杂的业务逻辑处理。

```mermaid
sequenceDiagram
participant Client as 客户端
participant Engine as 迁移引擎
participant Transaction as 事务管理器
participant DB as 数据库
Client->>Engine : 执行迁移请求
Engine->>Transaction : 开始事务
Transaction->>DB : 获取连接
Engine->>Engine : 验证前置条件
Engine->>DB : 执行迁移操作
DB-->>Engine : 返回结果
alt 迁移成功
Engine->>Transaction : 提交事务
Transaction->>DB : commit()
Engine-->>Client : 迁移完成
else 迁移失败
Engine->>Transaction : 回滚事务
Transaction->>DB : rollback()
Engine-->>Client : 抛出异常
end
```

**图表来源**
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L61-L99)

**章节来源**
- [setup.clj](file://src/metabase/app_db/setup.clj#L1-L100)
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L1-L100)

## 迁移任务实现方式

### 1. Liquibase SQL迁移

Liquibase负责处理数据库schema的DDL变更，提供标准化的迁移管理。

```mermaid
flowchart TD
A[开始迁移] --> B{检查锁状态}
B --> |获取锁成功| C[验证数据库连接]
B --> |获取锁失败| D[等待或超时]
C --> E[合并变更集]
E --> F[执行SQL迁移]
F --> G{迁移是否成功}
G --> |成功| H[提交事务]
G --> |失败| I[回滚事务]
H --> J[释放锁]
I --> K[清理资源]
D --> L[重试或退出]
```

**图表来源**
- [liquibase.clj](file://src/metabase/app_db/liquibase.clj#L350-L400)

### 2. 自定义数据迁移

自定义迁移处理复杂的业务数据转换和配置升级。

```mermaid
flowchart TD
A[定义迁移] --> B{是否可逆}
B --> |是| C[define-reversible-migration]
B --> |否| D[define-migration]
C --> E[正向迁移体]
C --> F[反向迁移体]
D --> E
E --> G[事务包装]
F --> G
G --> H[执行迁移]
H --> I{执行结果}
I --> |成功| J[更新状态]
I --> |失败| K[回滚操作]
```

**图表来源**
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L59-L99)

### 3. JSON结构化迁移

处理JSON字段的版本化迁移，确保数据格式的一致性。

```mermaid
flowchart TD
A[JSON字段] --> B{检查版本}
B --> |版本匹配| C[跳过迁移]
B --> |版本不匹配| D[查找迁移方法]
D --> E{找到方法}
E --> |找到| F[执行迁移]
E --> |未找到| G[使用默认行为]
F --> H[更新版本号]
H --> I[返回结果]
G --> I
C --> I
```

**图表来源**
- [json_migration.clj](file://src/metabase/models/json_migration.clj#L1-L54)

**章节来源**
- [liquibase.clj](file://src/metabase/app_db/liquibase.clj#L1-L100)
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L1-L200)
- [json_migration.clj](file://src/metabase/models/json_migration.clj#L1-L54)

## 幂等性设计

### 版本控制机制

Metabase通过版本控制系统确保迁移的幂等性：

```mermaid
stateDiagram-v2
[*] --> 检查版本
检查版本 --> 已最新 : 当前版本 = 目标版本
检查版本 --> 需要迁移 : 当前版本 < 目标版本
已最新 --> 跳过迁移
需要迁移 --> 执行迁移
执行迁移 --> 更新版本
更新版本 --> 迁移完成
跳过迁移 --> 迁移完成
迁移完成 --> [*]
```

### 条件执行检查

系统在执行每个迁移步骤前都会进行充分的条件检查：

```clojure
(defn should-execute-change?
  "检查变更是否应该被执行。
  这是一个工作绕过。回滚方法被调用两次：一次用于生成MDC数据，
  一次用于实际执行变更。这个相同的问题已经在Liquibase中为前进变更修复，
  但对回滚来说还没有。"
  []
  (BooleanUtil/isTrue (.get (Scope/getCurrentScope) Change/SHOULD_EXECUTE true)))
```

### 去重和幂等性保证

```mermaid
flowchart TD
A[开始迁移] --> B[检查变更历史]
B --> C{变更已执行?}
C --> |是| D[跳过重复执行]
C --> |否| E[执行迁移]
E --> F[标记为已执行]
F --> G[更新状态]
D --> H[继续下一个]
G --> H
```

**章节来源**
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L50-L60)
- [json_migration.clj](file://src/metabase/models/json_migration.clj#L3-L10)

## 执行顺序控制

### 迁移依赖图

```mermaid
graph TD
A[基础Schema] --> B[权限系统]
B --> C[用户数据]
C --> D[仪表板配置]
D --> E[查询历史]
E --> F[缓存设置]
G[破坏性变更] --> H[备份数据]
H --> I[执行变更]
I --> J[验证结果]
J --> K[清理临时数据]
```

### 分阶段迁移策略

系统采用分阶段的方式管理复杂的迁移流程：

1. **预检查阶段**：验证环境和前置条件
2. **数据准备阶段**：创建备份和临时表
3. **核心迁移阶段**：执行主要的数据变更
4. **验证阶段**：确认迁移结果的正确性
5. **清理阶段**：删除临时数据和清理状态

### 锁定机制

```mermaid
sequenceDiagram
participant M1 as 迁移实例1
participant M2 as 迁移实例2
participant Lock as 锁服务
participant DB as 数据库
M1->>Lock : 请求迁移锁
Lock->>DB : 检查现有锁
DB-->>Lock : 返回锁状态
Lock-->>M1 : 获得锁
M1->>DB : 执行迁移
M2->>Lock : 请求迁移锁
Lock->>DB : 检查现有锁
DB-->>Lock : 返回锁状态
Lock-->>M2 : 等待锁释放
M1->>DB : 完成迁移
M1->>Lock : 释放锁
Lock-->>M2 : 获得锁
M2->>DB : 执行迁移
```

**图表来源**
- [liquibase.clj](file://src/metabase/app_db/liquibase.clj#L350-L400)

**章节来源**
- [liquibase.clj](file://src/metabase/app_db/liquibase.clj#L350-L450)
- [setup.clj](file://src/metabase/app_db/setup.clj#L100-L150)

## 回滚策略

### 可逆迁移设计

```mermaid
classDiagram
class ReversibleMigration {
<<interface>>
+execute(database)
+rollback(database)
}
class MigrationRecord {
+id : string
+name : string
+version : int
+timestamp : datetime
+checksum : string
}
class RollbackStrategy {
+safeRollback()
+forceRollback()
+validateRollback()
}
ReversibleMigration --> MigrationRecord
ReversibleMigration --> RollbackStrategy
```

### 回滚触发条件

系统在以下情况下自动触发回滚：

1. **迁移失败**：执行过程中发生异常
2. **验证失败**：迁移结果不符合预期
3. **时间超时**：迁移执行时间超过限制
4. **手动干预**：管理员主动要求回滚

### 渐进式回滚

```mermaid
flowchart TD
A[检测到问题] --> B[停止当前迁移]
B --> C[评估影响范围]
C --> D{影响范围}
D --> |小范围| E[局部回滚]
D --> |大范围| F[完全回滚]
E --> G[恢复受影响数据]
F --> H[恢复完整备份]
G --> I[验证系统状态]
H --> I
I --> J[通知管理员]
```

### 回滚验证机制

```clojure
(defn rollback-validation
  [migration-id original-state]
  (let [current-state (capture-current-state)]
    (if (compare-states original-state current-state)
      (log/info "回滚验证成功")
      (log/error "回滚验证失败，需要人工干预"))))
```

**章节来源**
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L61-L99)
- [liquibase.clj](file://src/metabase/app_db/liquibase.clj#L550-L600)

## 错误处理和状态追踪

### 异常处理层次

```mermaid
graph TB
A[应用层异常] --> B[迁移控制器]
B --> C[事务管理器]
C --> D[数据库层]
E[网络异常] --> F[重试机制]
G[数据异常] --> H[数据修复]
I[权限异常] --> J[权限提升]
F --> K[最终处理]
H --> K
J --> K
K --> L[错误报告]
```

### 状态追踪系统

```mermaid
stateDiagram-v2
[*] --> 初始化
初始化 --> 准备中 : 开始迁移
准备中 --> 执行中 : 验证通过
执行中 --> 成功 : 正常完成
执行中 --> 失败 : 发生错误
执行中 --> 超时 : 时间超出
成功 --> [*]
失败 --> 回滚中 : 自动回滚
超时 --> 回滚中 : 强制回滚
回滚中 --> 已回滚 : 回滚完成
已回滚 --> [*]
```

### 日志和监控

系统提供详细的日志记录和实时监控：

```clojure
(defn log-migration-status
  [migration-id status message]
  (log/infof "迁移 %s 状态: %s - %s"
             migration-id
             status
             message))
```

### 错误恢复机制

```mermaid
flowchart TD
A[捕获异常] --> B[分类错误类型]
B --> C{错误类型}
C --> |可恢复| D[尝试恢复]
C --> |不可恢复| E[标记失败]
C --> |未知| F[人工介入]
D --> G{恢复成功?}
G --> |是| H[继续迁移]
G --> |否| E
E --> I[启动回滚]
F --> J[等待人工决策]
I --> K[清理资源]
J --> L[根据决策处理]
```

**章节来源**
- [setup.clj](file://src/metabase/app_db/setup.clj#L50-L150)
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L50-L100)

## 自定义迁移示例

### 示例1：权限系统迁移

```clojure
(define-reversible-migration SplitDataPermissions
  (let [current-perms-set (t2/select-fn-set
                           (juxt :object :group_id)
                           :permissions
                           {:where [:or
                                    [:like :object (h2x/literal "/db/%")]
                                    [:like :object (h2x/literal "/data/db/%")]
                                    [:like :object (h2x/literal "/query/db/%")]]})
        v2-perms-set      (into #{} (mapcat
                                     (fn [[v1-path group-id]]
                                       (for [v2-path (->v2-paths v1-path)]
                                         [v2-path group-id]))
                                     current-perms-set))
        new-v2-perms      (into [] (set/difference v2-perms-set current-perms-set))]
    (when (seq new-v2-perms)
      (t2.execute/query-one {:insert-into :permissions
                             :columns     [:object :group_id]
                             :values      new-v2-perms})))
  (t2.execute/query-one {:delete-from :permissions
                         :where [:or [:like :object (h2x/literal "/data/db/%")]
                                 [:like :object (h2x/literal "/query/db/%")]]}))
```

### 示例2：JSON字段升级

```clojure
(def-json-migration migrate-login-settings*)

(defmethod migrate-login-settings* [1 2] [login-settings _version]
  (assoc login-settings :remember_me_days (if (:remember_me login-settings) 30 0)))

(defn migrate-login-settings
  [login-settings]
  (-> login-settings
      (migrate-login-settings* login-settings-version)
      (update-version login-settings-version)))
```

### 示例3：破坏性变更处理

```clojure
(define-reversible-migration UnifyTimeColumnsType
  (unify-time-column-type! :up)
  (unify-time-column-type! :down))

(defn unify-time-column-type!
  [direction]
  (let [db-type (mdb.connection/db-type)
        columns (db-type->to-unified-columns db-type)
        target-type (case direction :up "TIMESTAMP WITH TIME ZONE" "TIMESTAMP WITHOUT TIME ZONE")]
    (doseq [[table column nullable?] columns]
      (t2/query [(alter-table-column-type-sql db-type table column target-type nullable?)]))))
```

**章节来源**
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L168-L200)
- [custom_migrations.clj](file://src/metabase/app_db/custom_migrations.clj#L1002-L1020)
- [json_migration.clj](file://src/metabase/models/json_migration.clj#L20-L50)

## 最佳实践

### 1. 迁移设计原则

- **最小化停机时间**：优先考虑在线迁移
- **数据一致性**：确保迁移过程中的数据完整性
- **可回滚性**：每个迁移都应有对应的回滚方案
- **测试覆盖**：充分的单元测试和集成测试

### 2. 性能优化策略

```mermaid
graph LR
A[批量处理] --> B[索引优化]
B --> C[并行执行]
C --> D[内存管理]
D --> E[监控指标]
F[预计算] --> G[缓存策略]
G --> H[增量迁移]
H --> I[压缩存储]
```

### 3. 安全考虑

- **权限控制**：严格的访问控制和审计
- **数据加密**：敏感数据的加密传输和存储
- **备份策略**：迁移前的完整备份
- **监控告警**：实时监控和异常告警

### 4. 运维建议

- **渐进式部署**：小规模试点后逐步推广
- **回滚计划**：制定详细的回滚预案
- **文档维护**：保持迁移文档的及时更新
- **团队培训**：定期进行迁移操作培训

### 5. 监控和维护

```clojure
(defn monitor-migration-health
  []
  (let [metrics (collect-migration-metrics)
        thresholds {:duration 3600 :errors 5 :warnings 10}]
    (when (> (:duration metrics) (:duration thresholds))
      (log/warn "迁移耗时过长"))
    (when (> (:errors metrics) (:errors thresholds))
      (log/error "迁移错误过多"))
    (when (> (:warnings metrics) (:warnings thresholds))
      (log/warn "迁移警告过多"))))
```

通过遵循这些最佳实践，可以确保Metabase迁移系统的稳定性和可靠性，为用户提供无缝的数据升级体验。