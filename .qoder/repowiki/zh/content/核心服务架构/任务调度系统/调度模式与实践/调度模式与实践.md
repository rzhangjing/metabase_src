# 调度模式与实践

<cite>
**本文档引用的文件**  
- [core.clj](file://src/metabase/task/core.clj)
- [impl.clj](file://src/metabase/task/impl.clj)
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md)
- [job_factory.clj](file://src/metabase/task/job_factory.clj)
- [bootstrap.clj](file://src/metabase/task/bootstrap.clj)
- [cron.clj](file://src/metabase/util/cron.clj)
- [send.clj](file://src/metabase/notification/task/send.clj)
- [sync_databases.clj](file://src/metabase/sync/task/sync_databases.clj)
</cite>

## 目录
1. [引言](#引言)
2. [任务调度模式分类](#任务调度模式分类)
3. [一次性启动任务](#一次性启动任务)
4. [周期性调度任务](#周期性调度任务)
5. [迁移类任务](#迁移类任务)
6. [Cron表达式使用方法](#cron表达式使用方法)
7. [时区处理策略](#时区处理策略)
8. [任务数据传递机制](#任务数据传递机制)
9. [错误处理策略](#错误处理策略)
10. [任务并发执行控制](#任务并发执行控制)
11. [Misfire处理策略](#misfire处理策略)
12. [代码示例与配置建议](#代码示例与配置建议)

## 引言
Metabase使用Quartz调度器来管理后台任务的执行。调度系统支持多种任务类型，包括一次性启动任务、周期性调度任务和迁移类任务。本文档详细说明了这些任务的实现方式，重点介绍了cron表达式的使用方法、时区处理策略、任务数据传递机制、错误处理策略以及如何防止任务并发执行和misfire处理策略的选择。

## 任务调度模式分类
Metabase中的任务调度主要分为三种模式：一次性启动任务、周期性调度任务和迁移类任务。每种模式都有其特定的使用场景和实现方式。

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L27-L55)

## 一次性启动任务
一次性启动任务在Metabase启动时执行一次。这些任务适用于初始化操作。在多实例部署环境中，这些任务会在每个实例启动时执行，因此需要确保任务的幂等性。

```clojure
(task/defjob StartupTask [_]
  (println "Running startup initialization task"))

(defmethod task/init! ::StartupTask [_]
  (let [job (jobs/build
             (jobs/of-type StartupTask)
             (jobs/with-identity startup-job-key)
             (jobs/with-description "One-time startup initialization task"))
        trigger (triggers/build
                 (triggers/with-identity startup-trigger-key)
                 (triggers/for-job startup-job-key)
                 (triggers/start-now))]
    (task/schedule-task! job trigger)))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L27-L55)

## 周期性调度任务
周期性调度任务按照cron表达式定义的计划重复执行。这些任务用于定期同步数据库、发送通知等操作。

```clojure
(task/defjob DailyTask [_]
  (println "Running daily scheduled task"))

(defmethod task/init! ::DailyTask [_]
  (let [job (jobs/build
             (jobs/of-type DailyTask)
             (jobs/with-identity daily-job-key)
             (jobs/with-description "Daily scheduled task")
             (jobs/store-durably))
        trigger (triggers/build
                 (triggers/with-identity daily-trigger-key)
                 (triggers/for-job daily-job-key)
                 (triggers/start-now)
                 (triggers/with-schedule
                  (cron/schedule
                   (cron/cron-schedule "0 0 2 * * ? *")
                   (cron/in-time-zone (driver/report-timezone)))))]
    (task/schedule-task! job trigger)))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L57-L90)

## 迁移类任务
对于一次性执行的迁移类任务，Metabase目前没有找到很好的解决方案。对于简单短小的任务，仍然建议使用自定义迁移。

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L92-L138)

## Cron表达式使用方法
Cron表达式用于定义任务的执行计划。Metabase提供了工具函数来转换前端调度字典与cron字符串。

```clojure
(cron/schedule
 (cron/cron-schedule "0 0 2 * * ? *")
 (cron/in-time-zone (driver/report-timezone)))
```

**Section sources**
- [cron.clj](file://src/metabase/util/cron.clj#L0-L160)

## 时区处理策略
默认情况下，Quartz调度器使用JVM的默认时区解释调度计划。在Metabase中，通常将时区设置为`report-timezone`。如果任务对时区敏感，当`driver/report-timezone`发生变化时，需要重建触发器。

```clojure
(cron/in-time-zone (driver/report-timezone))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L57-L90)

## 任务数据传递机制
可以通过作业数据映射将数据传递给任务：

```clojure
(triggers/using-job-data {"db-id" database-id})
```

在任务内部，可以访问这些数据：

```clojure
(task/defjob MyJob [job-context]
  (let [data-map (qc/from-job-data job-context)
        db-id (get data-map "db-id")]
    ;; 使用数据...
    ))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L92-L138)

## 错误处理策略
Metabase提供了一个`rerun-on-error`宏，用于在任务失败时自动重试：

```clojure
(task/defjob MyJob [job-context]
  (task/rerun-on-error job-context
    ;; 你的任务代码
    (do-something-that-might-fail)))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L138-L159)

## 任务并发执行控制
默认情况下，Quartz允许同一任务的多个实例并发执行。要防止任务并发执行，可以使用`DisallowConcurrentExecution`注解：

```clojure
(task/defjob ^{org.quartz.DisallowConcurrentExecution true} MyNonConcurrentJob [job-context]
  (println "This job will not run concurrently with itself"))
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L138-L159)

## Misfire处理策略
当触发器的预定触发时间过去而未触发时（通常是因为调度器已关闭）会发生misfire。Quartz提供了几种misfire处理指令：

```clojure
(cron/with-misfire-handling-instruction-do-nothing)        ;; 不触发错过的执行
(cron/with-misfire-handling-instruction-fire-and-proceed)  ;; 为错过的执行触发一次
(cron/with-misfire-handling-instruction-ignore-misfires)   ;; 触发所有错过的执行
```

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L138-L159)

## 代码示例与配置建议
以下是一些常见的任务配置示例和最佳实践建议：

1. **确保任务幂等性**：特别是在多实例部署环境中
2. **合理设置misfire处理策略**：根据任务的性质选择合适的策略
3. **正确处理时区**：使用`report-timezone`并考虑时区变化的影响
4. **防止并发执行**：对于长时间运行或操作共享资源的任务
5. **使用错误重试机制**：处理临时性错误

**Section sources**
- [QUARTZ.md](file://src/metabase/task/QUARTZ.md#L27-L159)