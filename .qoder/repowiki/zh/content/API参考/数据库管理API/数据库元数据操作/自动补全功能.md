# 自动补全功能

<cite>
**本文档引用的文件**   
- [api.clj](file://src/metabase/warehouses/api.clj)
</cite>

## 目录
1. [简介](#简介)
2. [核心端点实现](#核心端点实现)
3. [搜索匹配算法](#搜索匹配算法)
4. [结果排序逻辑](#结果排序逻辑)
5. [性能优化措施](#性能优化措施)
6. [请求示例与响应格式](#请求示例与响应格式)

## 简介
本文档详细记录了Metabase系统中元数据自动补全功能的实现机制。该功能主要通过`GET /api/database/:id/autocomplete_suggestions`和`GET /api/database/:id/card_autocomplete_suggestions`等API端点为用户提供智能提示，支持在编写SQL查询或创建模板标签时的自动补全。系统实现了表、字段和卡片的混合查询策略，结合了模糊搜索、前缀匹配和ID精确匹配等多种搜索技术，为用户提供高效准确的建议。

**Section sources**
- [api.clj](file://src/metabase/warehouses/api.clj#L574-L744)

## 核心端点实现
自动补全功能通过两个主要API端点实现：

1. **`GET /api/database/:id/autocomplete_suggestions`**：用于在用户编写原始SQL时提供表和字段的自动补全建议。该端点支持通过`prefix`（前缀匹配）或`substring`（子字符串匹配）参数进行搜索。

2. **`GET /api/database/:id/card_autocomplete_suggestions`**：用于在用户输入卡片模板标签（如`{{#...}}`）时提供卡片的自动补全建议。该端点根据查询字符串匹配卡片名称和ID。

两个端点均首先进行读取权限检查，确保用户有权访问指定的数据库。对于卡片自动补全，还支持通过`include_dashboard_questions`参数控制是否包含仪表板中的问题。

**Section sources**
- [api.clj](file://src/metabase/warehouses/api.clj#L698-L744)

## 搜索匹配算法
自动补全功能采用混合查询策略，结合多种匹配算法以提供最佳用户体验。

### 表和字段搜索
对于表和字段的搜索，系统使用基于PostgreSQL trgm（trigram）索引的模糊搜索算法。具体实现如下：

- **前缀匹配**：当用户提供`prefix`参数时，系统执行前缀匹配查询，使用`LIKE 'prefix%'`模式。
- **子字符串匹配**：当用户提供`substring`参数时，系统执行子字符串匹配查询，使用`LIKE '%substring%'`模式。
- **大小写不敏感匹配**：所有文本匹配均通过`LOWER()`函数转换为小写进行，确保搜索不区分大小写。

表搜索查询在`autocomplete-tables`函数中实现，匹配条件包括：
- 数据库ID匹配
- 表处于激活状态
- 表名（小写）与搜索字符串匹配
- 表可见性类型为nil（非隐藏表）

字段搜索查询在`autocomplete-fields`函数中实现，除了表的条件外，还增加了字段可见性检查（非敏感或退休字段）。

### 卡片搜索
卡片搜索采用更复杂的混合匹配策略，根据搜索字符串的格式智能选择匹配方式：

- **仅ID匹配**：如果搜索字符串仅为数字（如"123"），则作为前缀匹配卡片ID
- **ID+名称匹配**：如果搜索字符串包含数字和文本（如"123-foo"），则精确匹配卡片ID并前缀匹配卡片名称
- **仅名称匹配**：如果搜索字符串仅为文本（如"foo"），则作为子字符串匹配卡片名称

这种策略允许用户通过多种方式快速定位卡片，例如输入卡片ID的前几位或卡片名称的一部分。

**Section sources**
- [api.clj](file://src/metabase/warehouses/api.clj#L574-L698)

## 结果排序逻辑
自动补全结果采用多级排序策略，确保最相关的结果优先显示。

### 类型优先级排序
对于表和字段的混合结果，系统采用智能的权重分配算法：
- 表结果优先于字段结果
- 在字段结果中，根据字段所属的表名、基础类型和语义类型生成描述性标签
- 通过`autocomplete-results`函数计算表和字段的分配数量，确保结果列表中表和字段的比例合理

### 创建时间排序
对于卡片结果，系统采用双重排序策略：
1. **类型排序**：按卡片类型升序排列（"model"在"question"之前）
2. **创建时间排序**：按卡片ID降序排列（最近创建的卡片优先）

这种排序方式确保了模型卡片优先显示，并且最近使用的卡片更容易被找到，符合用户的使用习惯。

**Section sources**
- [api.clj](file://src/metabase/warehouses/api.clj#L574-L698)

## 性能优化措施
为确保自动补全功能的响应速度和系统性能，系统实施了多项优化措施。

### 缓存策略
系统采用HTTP缓存机制，为自动补全响应设置60秒的缓存有效期（`max-age=60`）。这一策略基于以下考虑：
- 用户在编写查询时会重复输入相似的前缀
- 60秒的缓存时间足够短，不会因模式或权限变更造成困扰
- 缓存是用户特定的，因为系统会检查权限

缓存头信息设置如下：
```
Cache-Control: public, max-age=60
Vary: Cookie
```

### 数据库索引
系统使用PostgreSQL的trgm（trigram）索引显著提升模糊搜索性能。在`autocomplete-fields`查询中，trgm索引可将查询性能提升约4倍。此外，系统还在`lower(metabase_field.name)`上创建了索引，用于优化排序操作。

### 查询优化
- **限制结果数量**：所有自动补全查询均设置50条结果的限制，防止返回过多数据
- **权限过滤**：在数据库查询层面进行权限检查，减少不必要的数据传输
- **连接优化**：使用内连接（INNER JOIN）检查表的激活状态，提升查询效率

**Section sources**
- [api.clj](file://src/metabase/warehouses/api.clj#L698-L721)

## 请求示例与响应格式
本节提供自动补全功能的实际使用示例。

### 表和字段建议
**请求示例：**
```
GET /api/database/1/autocomplete_suggestions?prefix=use
```

**响应格式：**
```json
[
  ["users", "Table"],
  ["user_id", "users type/Integer"],
  ["username", "users type/Text"],
  ["user_email", "users type/Text Semantic/Email"]
]
```
表建议格式为`[表名, "Table"]`，字段建议格式为`[字段名, "表名 基础类型 语义类型"]`（如果存在语义类型）。

### 卡片建议
**请求示例：**
```
GET /api/database/1/card_autocomplete_suggestions?query=123-user
```

**响应格式：**
```json
[
  {
    "id": 123,
    "name": "User Analysis",
    "type": "question",
    "collection_name": "Analytics"
  },
  {
    "id": 124,
    "name": "User Demographics",
    "type": "question",
    "collection_name": "Analytics"
  }
]
```
卡片建议返回卡片ID、名称、类型和所属集合名称，便于用户识别和选择。

**Section sources**
- [api.clj](file://src/metabase/warehouses/api.clj#L698-L744)