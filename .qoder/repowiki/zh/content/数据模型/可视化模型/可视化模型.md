# 可视化模型

<cite>
**本文档中引用的文件**  
- [dashboard.clj](file://src/metabase/dashboards/models/dashboard.clj)
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj)
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj)
- [dashboard_card_series.clj](file://src/metabase/dashboards/models/dashboard_card_series.clj)
- [schema.clj](file://src/metabase/dashboards/schema.clj)
- [autoplace.clj](file://src/metabase/dashboards/autoplace.clj)
- [api.clj](file://src/metabase/dashboards/api.clj)
- [revision.clj](file://src/metabase/revisions/models/revision.clj)
- [parameters.clj](file://src/metabase/parameters/dashboard.clj)
- [settings.clj](file://src/metabase/dashboards/settings.clj)
</cite>

## 目录
1. [引言](#引言)
2. [核心实体结构](#核心实体结构)
3. [布局与排序机制](#布局与排序机制)
4. [参数映射与过滤](#参数映射与过滤)
5. [标签页管理](#标签页管理)
6. [版本控制与变更追踪](#版本控制与变更追踪)
7. [序列化与迁移](#序列化与迁移)
8. [性能优化策略](#性能优化策略)
9. [高级功能实现](#高级功能实现)

## 引言

Metabase的可视化模型以Dashboard为核心，提供了一个强大的数据展示平台。该模型通过Dashboard、DashboardCard、DashboardTab等实体的协同工作，实现了复杂的数据可视化需求。仪表板不仅支持多种图表类型的展示，还提供了参数化查询、自动布局、标签页管理等高级功能。本文档深入解析这些核心组件的结构与关系，阐述其集成方式和工作机制。

## 核心实体结构

可视化模型的核心由Dashboard、DashboardCard、DashboardTab和DashboardCardSeries四个主要实体构成。这些实体通过明确的关系定义，形成了一个层次化的数据展示结构。

```mermaid
classDiagram
class Dashboard {
+id : Integer
+name : String
+description : String
+parameters : List[Parameter]
+archived : Boolean
+collection_id : Integer
+created_at : Timestamp
+updated_at : Timestamp
}
class DashboardCard {
+id : Integer
+dashboard_id : Integer
+card_id : Integer
+action_id : Integer
+row : Integer
+col : Integer
+size_x : Integer
+size_y : Integer
+parameter_mappings : List[ParameterMapping]
+visualization_settings : Map
+inline_parameters : List[String]
+dashboard_tab_id : Integer
+created_at : Timestamp
+updated_at : Timestamp
}
class DashboardTab {
+id : Integer
+dashboard_id : Integer
+name : String
+position : Integer
+created_at : Timestamp
+updated_at : Timestamp
}
class DashboardCardSeries {
+id : Integer
+dashboardcard_id : Integer
+card_id : Integer
+position : Integer
}
Dashboard "1" *-- "0..*" DashboardCard : 包含
Dashboard "1" *-- "0..*" DashboardTab : 包含
DashboardCard "1" *-- "0..*" DashboardCardSeries : 系列
DashboardCard "1" -- "1" DashboardTab : 属于标签页
DashboardCard "1" -- "1" Card : 关联查询
DashboardCard "1" -- "0..*" ParameterMapping : 参数映射
```

**Diagram sources**
- [dashboard.clj](file://src/metabase/dashboards/models/dashboard.clj#L1-L503)
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj#L1-L411)
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj#L1-L133)
- [dashboard_card_series.clj](file://src/metabase/dashboards/models/dashboard_card_series.clj#L1-L25)

**Section sources**
- [dashboard.clj](file://src/metabase/dashboards/models/dashboard.clj#L1-L503)
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj#L1-L411)

## 布局与排序机制

仪表板的布局系统采用网格化设计，通过行（row）、列（col）、宽度（size_x）和高度（size_y）四个维度来定位卡片。这种设计确保了卡片在仪表板上的精确排列和响应式布局。

### 自动布局算法

自动布局功能通过`autoplace.clj`文件中的`get-position-for-new-dashcard`函数实现。该算法在添加新卡片时，会扫描现有卡片的位置，寻找第一个可用的空间。

```mermaid
flowchart TD
Start([开始添加新卡片]) --> CheckExistingCards["检查现有卡片位置"]
CheckExistingCards --> FindAvailablePosition["寻找可用位置"]
FindAvailablePosition --> PositionFound{"找到位置?"}
PositionFound --> |是| PlaceCard["放置卡片"]
PositionFound --> |否| ReturnNil["返回nil"]
PlaceCard --> End([完成])
ReturnNil --> End
```

**Diagram sources**
- [autoplace.clj](file://src/metabase/dashboards/autoplace.clj#L1-L56)

### 卡片排序

卡片的排序遵循从左到右、从上到下的原则，通过`dashcard-comparator`函数实现。该函数比较两个卡片的行和列坐标，确定它们在布局中的相对位置。

```mermaid
flowchart TD
CompareCards["比较两个卡片"]
CompareCards --> SameRow{"行相同?"}
SameRow --> |是| CompareCol["比较列坐标"]
SameRow --> |否| CompareRow["比较行坐标"]
CompareCol --> OrderByCol["按列排序"]
CompareRow --> OrderByRow["按行排序"]
OrderByCol --> End
OrderByRow --> End
```

**Diagram sources**
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj#L370-L385)

**Section sources**
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj#L370-L385)

## 参数映射与过滤

参数映射是仪表板实现交互式数据展示的核心机制。通过将仪表板参数与卡片参数关联，用户可以在仪表板级别设置过滤条件，影响多个卡片的数据展示。

### 参数映射结构

参数映射通过`parameter_mappings`字段实现，每个映射包含参数ID、卡片ID和目标字段。这种设计允许一个仪表板参数影响多个卡片的不同字段。

```mermaid
classDiagram
class Parameter {
+id : String
+name : String
+type : String
+slug : String
}
class ParameterMapping {
+parameter_id : String
+card_id : Integer
+target : List
}
class DashboardCard {
+parameter_mappings : List[ParameterMapping]
}
Parameter "1" *-- "0..*" ParameterMapping : 映射到
ParameterMapping "1" -- "1" DashboardCard : 属于
```

**Diagram sources**
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj#L1-L411)
- [parameters.clj](file://src/metabase/parameters/dashboard.clj#L1-L223)

### 链式过滤

链式过滤功能允许参数之间相互约束，实现更复杂的过滤逻辑。当一个参数的值发生变化时，它会影响其他相关参数的可选值范围。

```mermaid
sequenceDiagram
participant User as "用户"
participant Dashboard as "仪表板"
participant ParameterA as "参数A"
participant ParameterB as "参数B"
User->>Dashboard : 选择参数A的值
Dashboard->>ParameterA : 接收值
ParameterA->>ParameterB : 触发更新
ParameterB->>Dashboard : 返回过滤后的可选值
Dashboard->>User : 更新参数B的选项
```

**Diagram sources**
- [parameters.clj](file://src/metabase/parameters/dashboard.clj#L1-L223)

**Section sources**
- [parameters.clj](file://src/metabase/parameters/dashboard.clj#L1-L223)

## 标签页管理

标签页功能通过`DashboardTab`实体实现，允许将相关卡片组织在不同的标签页中，提高仪表板的可管理性和用户体验。

### 标签页操作

标签页的创建、更新和删除通过`do-update-tabs!`函数统一处理。该函数比较当前标签页和新标签页的差异，执行相应的创建、更新或删除操作。

```mermaid
flowchart TD
Start([开始更新标签页]) --> DiffTabs["比较新旧标签页"]
DiffTabs --> CreateTabs["创建新标签页"]
DiffTabs --> UpdateTabs["更新现有标签页"]
DiffTabs --> DeleteTabs["删除标签页"]
CreateTabs --> UpdateCardTabs["更新卡片标签页ID"]
UpdateTabs --> UpdateCardTabs
DeleteTabs --> UpdateCardTabs
UpdateCardTabs --> End([完成])
```

**Diagram sources**
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj#L1-L133)

### 标签页与卡片关系

每个`DashboardCard`通过`dashboard_tab_id`字段关联到特定的标签页。当标签页被删除时，其下的所有卡片会被移动到默认标签页或被删除。

```mermaid
erDiagram
DASHBOARD ||--o{ DASHBOARD_TAB : "1:N"
DASHBOARD_TAB ||--o{ DASHBOARD_CARD : "1:N"
DASHBOARD ||--o{ DASHBOARD_CARD : "1:N"
DASHBOARD {
integer id
string name
timestamp created_at
timestamp updated_at
}
DASHBOARD_TAB {
integer id
integer dashboard_id
string name
integer position
timestamp created_at
timestamp updated_at
}
DASHBOARD_CARD {
integer id
integer dashboard_id
integer card_id
integer dashboard_tab_id
integer row
integer col
integer size_x
integer size_y
timestamp created_at
timestamp updated_at
}
```

**Diagram sources**
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj#L1-L133)
- [dashboard_card.clj](file://src/metabase/dashboards/models/dashboard_card.clj#L1-L411)

**Section sources**
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj#L1-L133)

## 版本控制与变更追踪

仪表板的版本控制通过修订系统（Revisions）实现，记录每次变更的历史，支持回滚到之前的版本。

### 修订模型

`Revision`实体记录了每次变更的详细信息，包括变更对象、用户、时间戳和变更内容。每个修订都有一个`most_recent`标志，指示是否为最新版本。

```mermaid
classDiagram
class Revision {
+id : Integer
+model : String
+model_id : Integer
+user_id : Integer
+object : Map
+is_creation : Boolean
+is_reversion : Boolean
+message : String
+timestamp : Timestamp
+metabase_version : String
+most_recent : Boolean
}
class User {
+id : Integer
+first_name : String
+last_name : String
+common_name : String
}
Revision "1" -- "1" User : 由...创建
```

**Diagram sources**
- [revision.clj](file://src/metabase/revisions/models/revision.clj#L1-L254)

### 变更追踪流程

当仪表板发生变更时，系统会创建一个新的修订记录。如果变更内容与上一个修订相同，则不会创建新的修订。

```mermaid
sequenceDiagram
participant System as "系统"
participant Dashboard as "仪表板"
participant Revision as "修订"
System->>Dashboard : 检测到变更
Dashboard->>Revision : 获取上一个修订
Revision-->>Dashboard : 返回上一个修订
Dashboard->>System : 比较变更内容
alt 内容不同
System->>Revision : 创建新修订
Revision-->>System : 返回新修订
System->>Revision : 更新most_recent标志
end
System-->>User : 完成变更
```

**Diagram sources**
- [revision.clj](file://src/metabase/revisions/models/revision.clj#L1-L254)

**Section sources**
- [revision.clj](file://src/metabase/revisions/models/revision.clj#L1-L254)

## 序列化与迁移

仪表板的序列化格式支持在不同环境间的迁移，确保配置的一致性和可移植性。

### 序列化配置

序列化配置通过`make-spec`函数定义，指定了哪些字段需要复制、跳过或转换。这种配置确保了关键数据的完整迁移。

```mermaid
flowchart TD
Start([开始序列化]) --> DefineSpec["定义序列化规范"]
DefineSpec --> CopyFields["复制指定字段"]
DefineSpec --> SkipFields["跳过指定字段"]
DefineSpec --> TransformFields["转换指定字段"]
CopyFields --> ProcessNested["处理嵌套对象"]
SkipFields --> ProcessNested
TransformFields --> ProcessNested
ProcessNested --> GeneratePath["生成路径"]
GeneratePath --> End([完成序列化])
```

**Diagram sources**
- [dashboard.clj](file://src/metabase/dashboards/models/dashboard.clj#L406-L450)

### 依赖关系

序列化过程中会分析对象间的依赖关系，确保所有相关对象都被正确迁移。依赖关系包括卡片、集合、动作等。

```mermaid
graph TD
Dashboard --> DashboardCard
DashboardCard --> Card
DashboardCard --> Action
DashboardCard --> ParameterMapping
Dashboard --> Collection
DashboardCard --> DashboardTab
DashboardCardSeries --> Card
DashboardCard --> DashboardCardSeries
```

**Diagram sources**
- [dashboard.clj](file://src/metabase/dashboards/models/dashboard.clj#L431-L450)

**Section sources**
- [dashboard.clj](file://src/metabase/dashboards/models/dashboard.clj#L406-L450)

## 性能优化策略

针对大型仪表板的性能优化，系统提供了多种策略，包括缓存机制、批量加载和自动刷新配置。

### 缓存机制

系统使用`dashboard-load-id`作为缓存键，对仪表板加载过程中的元数据进行缓存，减少重复的数据库查询。

```mermaid
flowchart TD
Start([开始加载仪表板]) --> CheckCache["检查缓存"]
CheckCache --> CacheHit{"缓存命中?"}
CacheHit --> |是| UseCache["使用缓存数据"]
CacheHit --> |否| LoadFromDB["从数据库加载"]
LoadFromDB --> CacheData["缓存数据"]
CacheData --> UseCache
UseCache --> End([返回数据])
```

**Diagram sources**
- [api.clj](file://src/metabase/dashboards/api.clj#L272-L328)

### 自动刷新配置

自动刷新功能允许仪表板定期更新数据，保持信息的实时性。刷新间隔可以通过`dashboard.settings`进行配置。

```mermaid
classDiagram
class DashboardSettings {
+dashboards-save-last-used-parameters : Boolean
}
class Dashboard {
+refresh_interval : Integer
}
DashboardSettings "1" -- "1" Dashboard : 配置
```

**Diagram sources**
- [settings.clj](file://src/metabase/dashboards/settings.clj#L1-L12)

**Section sources**
- [settings.clj](file://src/metabase/dashboards/settings.clj#L1-L12)

## 高级功能实现

### 自动布局实现

自动布局功能通过`get-position-for-new-dashcard`函数实现，该函数在添加新卡片时自动寻找最佳位置。

```mermaid
flowchart TD
Start([添加新卡片]) --> GetExistingCards["获取现有卡片"]
GetExistingCards --> LoopRows["循环行"]
LoopRows --> LoopCols["循环列"]
LoopCols --> CheckIntersection["检查是否重叠"]
CheckIntersection --> CanPlace{"可以放置?"}
CanPlace --> |是| ReturnPosition["返回位置"]
CanPlace --> |否| NextCol["下一列"]
NextCol --> LoopCols
ReturnPosition --> End
```

**Diagram sources**
- [autoplace.clj](file://src/metabase/dashboards/autoplace.clj#L1-L56)

### 标签页管理实现

标签页管理通过`do-update-tabs!`函数实现，该函数处理标签页的创建、更新和删除操作。

```mermaid
flowchart TD
Start([更新标签页]) --> DiffTabs["比较新旧标签页"]
DiffTabs --> CreateTabs["创建新标签页"]
CreateTabs --> UpdateCards["更新卡片标签页ID"]
DiffTabs --> UpdateTabs["更新现有标签页"]
UpdateTabs --> UpdateCards
DiffTabs --> DeleteTabs["删除标签页"]
DeleteTabs --> UpdateCards
UpdateCards --> End([完成])
```

**Diagram sources**
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj#L1-L133)

**Section sources**
- [autoplace.clj](file://src/metabase/dashboards/autoplace.clj#L1-L56)
- [dashboard_tab.clj](file://src/metabase/dashboards/models/dashboard_tab.clj#L1-L133)